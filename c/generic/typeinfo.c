/* Welcome to macro hell! */
#include "logger.h"
#include "typeinfo.h"

/**
 * 
 * BEGIN:   GENERATE DATA MACRO
 * 
 * BRIEF:   It's generally reasonable to want to zero out data. For fundamental
 *          fundamental types, we do just that!
 * 
 * NOTE:    This should also work for structs as well. `(T){0}` works for both
 *          fundamental types and for struct types (as of C11).
 */

#define generate_data(K, T) \
static void *init_##K(void *dst) \
{ \
    *(T*)dst = (T){0}; \
    return dst; \
} \
static void *copy_##K(void *dst, const void *src) \
{ \
    *(T*)dst = *(T*)src;\
    return dst; \
} \
static void *move_##K(void *dst, void *src) \
{ \
    *(T*)dst = *(T*)src; \
    *(T*)src = (T){0}; \
    return dst; \
} \
static void deinit_##K(void *dst) \
{ \
    *(T*)dst = (T){0}; \
} \
const ti_typefns fnlist_##K = { \
    .init = init_##K, \
    .copy = copy_##K, \
    .move = move_##K, \
    .deinit = deinit_##K, \
};
/**
 * END:     GENERATE DATA MACRO
 */

/* Empty function-like macro argument IS valid! */
#define generate_intdata(callback) \
    callback(, int) \
    callback(l, long) \
    callback(ll, long long) \
    callback(h, short) \
    callback(hh, char)

#define generate_chardata(callback) \
    callback(, char) \
    callback(l, wchar_t)

#define signedfns(K, T)     generate_data(K##i, signed T)
#define unsignedfns(K, T)   generate_data(K##u, unsigned T)
#define charfns(K, T)       generate_data(K##c, T)
#define stringfns(K, T)     generate_data(K##s, T*)

generate_intdata(signedfns)
generate_intdata(unsignedfns)
generate_chardata(charfns)
generate_chardata(stringfns)
generate_data(zu, size_t)
generate_data(p, void *)
    
/** 
 * In order to use `C_Spec` as an argument for both `fnlist` and `spec`.
 * For `fnlist`, we use it as is via the `##` argument/token expansion.
 * For `spec`, we convert it to a `const char*` and get the first character.
 * 
 * There is no way to conver a macro argument to a character literal:
 * https://gcc.gnu.org/onlinedocs/gcc-4.8.5/cpp/Stringification.html
 */
#define generate_ti(key, ctype, cprefix, cspec, csign) \
    [key] = {  \
        .size = sizeof(ctype), \
        .fnlist = &(fnlist_##cprefix##cspec), \
        .length = key, \
        .spec = #cspec[0], \
        .is_signed = csign, \
        .is_fundamental = true, \
    },

#define signed_ti(K, T, prefix)    generate_ti(K, signed T, prefix, i, true)
#define unsigned_ti(K, T, prefix)  generate_ti(K, unsigned T, prefix, u, false)
    
/** 
 * Not just for int, works for all integral types. 
 * Note that #1 specifically needs the trailing comma to indicate an empty arg.
 */
#define generate_int_ti(callback) \
    callback(TI_LENGTH_NONE,   int,) \
    callback(TI_LENGTH_LONG,   long, l) \
    callback(TI_LENGTH_LLONG,  long long, ll) \
    callback(TI_LENGTH_SHORT,  short, h) \
    callback(TI_LENGTH_SSHORT, char, hh)

/**
 * END:     MACRO HELL (GENERATING FUNDAMENTAL TYPEINFO)
 */
    
#define CHAR_IS_SIGNED  (CHAR_MIN == SCHAR_MIN)
#define WCHAR_IS_SIGNED (WCHAR_MIN != 0)

const ti_lookup ti_fundtypes = {
    .i = {
        generate_int_ti(signed_ti)
    },
    .u = {
        generate_int_ti(unsigned_ti)
        generate_ti(TI_LENGTH_SIZE_T, size_t, z, u, false)
    },
    // Actually, most string operations don't care about signedness anyway.
    .c = {
        [TI_LENGTH_NONE] = {
            .size = sizeof(char),
            .fnlist = &fnlist_c, // Generated by `generate_fnlists_char`.
            .length = TI_LENGTH_NONE,
            .spec = 'c',
            .is_signed = CHAR_IS_SIGNED,
            .is_fundamental = true,
        },
        [TI_LENGTH_LONG] = {
            .size = sizeof(wchar_t),
            .fnlist = &fnlist_lc, // Generated by `generate_fnlists_char`.
            .length = TI_LENGTH_NONE,
            .spec = 'c',
            .is_signed = WCHAR_IS_SIGNED,
            .is_fundamental = true
        },
    },
    .s = {
        [TI_LENGTH_NONE] = {
            .size = sizeof(char*),
            .fnlist = &fnlist_s, // Generated by `generate_fnlists_char`.
            .length = TI_LENGTH_NONE,
            .spec = 's',
            .is_signed = CHAR_IS_SIGNED,
            .is_fundamental = true,
        },
        [TI_LENGTH_LONG] = {
            .size = sizeof(wchar_t *),
            .fnlist = &fnlist_ls, // Generated by `generate_fnlists_char`.
            .length = TI_LENGTH_NONE,
            .spec = 's',
            .is_signed = WCHAR_IS_SIGNED,
            .is_fundamental = true,
        },
    },
    .p = {
        .size = sizeof(void *),
        .fnlist = &fnlist_p, // Generated by `generate_data(p, void*)`.
        .length = TI_LENGTH_NONE,
        .spec = 'p',
        .is_signed = false,
        .is_fundamental = true,
    },
};

const ti_typeinfo *ti_query(char spec, ti_typelength len)
{
    if (len >= TI_LENGTH_COUNT) {
        goto badquery; // Using `goto` so we can also print error message.
    }
    // Order of struct member w/ address-of operator is funky, need parentheses.
    switch (spec)
    {
        case 'i': return &(ti_fundtypes.i[len]);
        case 'u': return &(ti_fundtypes.u[len]);
        case 'c': return &(ti_fundtypes.c[len]);
        case 's': return &(ti_fundtypes.s[len]);
        case 'p': return &(ti_fundtypes.p);
        default:  break;
    }
badquery:
    lg_logprintf("ti_query", "Invalid spec %c and/or len %i", spec, (int)len);
    return nullptr;
}

